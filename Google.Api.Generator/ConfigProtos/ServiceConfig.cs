// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: service_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Grpc.ServiceConfig {

  /// <summary>Holder for reflection information generated from service_config.proto</summary>
  public static partial class ServiceConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for service_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ServiceConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChRzZXJ2aWNlX2NvbmZpZy5wcm90bxITZ3JwYy5zZXJ2aWNlX2NvbmZpZxoe",
            "Z29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh5nb29nbGUvcHJvdG9i",
            "dWYvd3JhcHBlcnMucHJvdG8aFWdvb2dsZS9ycGMvY29kZS5wcm90byLhBgoM",
            "TWV0aG9kQ29uZmlnEjQKBG5hbWUYASADKAsyJi5ncnBjLnNlcnZpY2VfY29u",
            "ZmlnLk1ldGhvZENvbmZpZy5OYW1lEjIKDndhaXRfZm9yX3JlYWR5GAIgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRIqCgd0aW1lb3V0GAMgASgL",
            "MhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEj8KGW1heF9yZXF1ZXN0X21l",
            "c3NhZ2VfYnl0ZXMYBCABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFs",
            "dWUSQAoabWF4X3Jlc3BvbnNlX21lc3NhZ2VfYnl0ZXMYBSABKAsyHC5nb29n",
            "bGUucHJvdG9idWYuVUludDMyVmFsdWUSRQoMcmV0cnlfcG9saWN5GAYgASgL",
            "Mi0uZ3JwYy5zZXJ2aWNlX2NvbmZpZy5NZXRob2RDb25maWcuUmV0cnlQb2xp",
            "Y3lIABJJCg5oZWRnaW5nX3BvbGljeRgHIAEoCzIvLmdycGMuc2VydmljZV9j",
            "b25maWcuTWV0aG9kQ29uZmlnLkhlZGdpbmdQb2xpY3lIABonCgROYW1lEg8K",
            "B3NlcnZpY2UYASABKAkSDgoGbWV0aG9kGAIgASgJGtUBCgtSZXRyeVBvbGlj",
            "eRIUCgxtYXhfYXR0ZW1wdHMYASABKA0SMgoPaW5pdGlhbF9iYWNrb2ZmGAIg",
            "ASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEi4KC21heF9iYWNrb2Zm",
            "GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEhoKEmJhY2tvZmZf",
            "bXVsdGlwbGllchgEIAEoAhIwChZyZXRyeWFibGVfc3RhdHVzX2NvZGVzGAUg",
            "AygOMhAuZ29vZ2xlLnJwYy5Db2RlGokBCg1IZWRnaW5nUG9saWN5EhQKDG1h",
            "eF9hdHRlbXB0cxgBIAEoDRIwCg1oZWRnaW5nX2RlbGF5GAIgASgLMhkuZ29v",
            "Z2xlLnByb3RvYnVmLkR1cmF0aW9uEjAKFm5vbl9mYXRhbF9zdGF0dXNfY29k",
            "ZXMYAyADKA4yEC5nb29nbGUucnBjLkNvZGVCGQoXcmV0cnlfb3JfaGVkZ2lu",
            "Z19wb2xpY3kiEQoPUGlja0ZpcnN0Q29uZmlnIhIKEFJvdW5kUm9iaW5Db25m",
            "aWciTgoMR3JwY0xiQ29uZmlnEj4KDGNoaWxkX3BvbGljeRgBIAMoCzIoLmdy",
            "cGMuc2VydmljZV9jb25maWcuTG9hZEJhbGFuY2luZ0NvbmZpZyKlAQoJWGRz",
            "Q29uZmlnEhUKDWJhbGFuY2VyX25hbWUYASABKAkSPgoMY2hpbGRfcG9saWN5",
            "GAIgAygLMiguZ3JwYy5zZXJ2aWNlX2NvbmZpZy5Mb2FkQmFsYW5jaW5nQ29u",
            "ZmlnEkEKD2ZhbGxiYWNrX3BvbGljeRgDIAMoCzIoLmdycGMuc2VydmljZV9j",
            "b25maWcuTG9hZEJhbGFuY2luZ0NvbmZpZyLkAgoTTG9hZEJhbGFuY2luZ0Nv",
            "bmZpZxJGCgpwaWNrX2ZpcnN0GAQgASgLMiQuZ3JwYy5zZXJ2aWNlX2NvbmZp",
            "Zy5QaWNrRmlyc3RDb25maWdIAFIKcGlja19maXJzdBJJCgtyb3VuZF9yb2Jp",
            "bhgBIAEoCzIlLmdycGMuc2VydmljZV9jb25maWcuUm91bmRSb2JpbkNvbmZp",
            "Z0gAUgtyb3VuZF9yb2JpbhIzCgZncnBjbGIYAyABKAsyIS5ncnBjLnNlcnZp",
            "Y2VfY29uZmlnLkdycGNMYkNvbmZpZ0gAEi0KA3hkcxgCIAEoCzIeLmdycGMu",
            "c2VydmljZV9jb25maWcuWGRzQ29uZmlnSAASTAoQeGRzX2V4cGVyaW1lbnRh",
            "bBgFIAEoCzIeLmdycGMuc2VydmljZV9jb25maWcuWGRzQ29uZmlnSABSEHhk",
            "c19leHBlcmltZW50YWxCCAoGcG9saWN5ItgECg1TZXJ2aWNlQ29uZmlnElkK",
            "FWxvYWRfYmFsYW5jaW5nX3BvbGljeRgBIAEoDjI2LmdycGMuc2VydmljZV9j",
            "b25maWcuU2VydmljZUNvbmZpZy5Mb2FkQmFsYW5jaW5nUG9saWN5QgIYARJH",
            "ChVsb2FkX2JhbGFuY2luZ19jb25maWcYBCADKAsyKC5ncnBjLnNlcnZpY2Vf",
            "Y29uZmlnLkxvYWRCYWxhbmNpbmdDb25maWcSOAoNbWV0aG9kX2NvbmZpZxgC",
            "IAMoCzIhLmdycGMuc2VydmljZV9jb25maWcuTWV0aG9kQ29uZmlnElIKEHJl",
            "dHJ5X3Rocm90dGxpbmcYAyABKAsyOC5ncnBjLnNlcnZpY2VfY29uZmlnLlNl",
            "cnZpY2VDb25maWcuUmV0cnlUaHJvdHRsaW5nUG9saWN5ElEKE2hlYWx0aF9j",
            "aGVja19jb25maWcYBSABKAsyNC5ncnBjLnNlcnZpY2VfY29uZmlnLlNlcnZp",
            "Y2VDb25maWcuSGVhbHRoQ2hlY2tDb25maWcaQAoVUmV0cnlUaHJvdHRsaW5n",
            "UG9saWN5EhIKCm1heF90b2tlbnMYASABKA0SEwoLdG9rZW5fcmF0aW8YAiAB",
            "KAIaRwoRSGVhbHRoQ2hlY2tDb25maWcSMgoMc2VydmljZV9uYW1lGAEgASgL",
            "MhwuZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlIjcKE0xvYWRCYWxhbmNp",
            "bmdQb2xpY3kSDwoLVU5TUEVDSUZJRUQQABIPCgtST1VORF9ST0JJThABQi0K",
            "FWlvLmdycGMuc2VydmljZWNvbmZpZ0ISU2VydmljZUNvbmZpZ1Byb3RvUAFi",
            "BnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Rpc.CodeReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.MethodConfig), global::Grpc.ServiceConfig.MethodConfig.Parser, new[]{ "Name", "WaitForReady", "Timeout", "MaxRequestMessageBytes", "MaxResponseMessageBytes", "RetryPolicy", "HedgingPolicy" }, new[]{ "RetryOrHedgingPolicy" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.MethodConfig.Types.Name), global::Grpc.ServiceConfig.MethodConfig.Types.Name.Parser, new[]{ "Service", "Method" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy), global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy.Parser, new[]{ "MaxAttempts", "InitialBackoff", "MaxBackoff", "BackoffMultiplier", "RetryableStatusCodes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy), global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy.Parser, new[]{ "MaxAttempts", "HedgingDelay", "NonFatalStatusCodes" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.PickFirstConfig), global::Grpc.ServiceConfig.PickFirstConfig.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.RoundRobinConfig), global::Grpc.ServiceConfig.RoundRobinConfig.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.GrpcLbConfig), global::Grpc.ServiceConfig.GrpcLbConfig.Parser, new[]{ "ChildPolicy" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.XdsConfig), global::Grpc.ServiceConfig.XdsConfig.Parser, new[]{ "BalancerName", "ChildPolicy", "FallbackPolicy" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.LoadBalancingConfig), global::Grpc.ServiceConfig.LoadBalancingConfig.Parser, new[]{ "PickFirst", "RoundRobin", "Grpclb", "Xds", "XdsExperimental" }, new[]{ "Policy" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.ServiceConfig), global::Grpc.ServiceConfig.ServiceConfig.Parser, new[]{ "LoadBalancingPolicy", "LoadBalancingConfig", "MethodConfig", "RetryThrottling", "HealthCheckConfig" }, null, new[]{ typeof(global::Grpc.ServiceConfig.ServiceConfig.Types.LoadBalancingPolicy) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.ServiceConfig.Types.RetryThrottlingPolicy), global::Grpc.ServiceConfig.ServiceConfig.Types.RetryThrottlingPolicy.Parser, new[]{ "MaxTokens", "TokenRatio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Grpc.ServiceConfig.ServiceConfig.Types.HealthCheckConfig), global::Grpc.ServiceConfig.ServiceConfig.Types.HealthCheckConfig.Parser, new[]{ "ServiceName" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for a method.
  /// </summary>
  public sealed partial class MethodConfig : pb::IMessage<MethodConfig> {
    private static readonly pb::MessageParser<MethodConfig> _parser = new pb::MessageParser<MethodConfig>(() => new MethodConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MethodConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MethodConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MethodConfig(MethodConfig other) : this() {
      name_ = other.name_.Clone();
      WaitForReady = other.WaitForReady;
      timeout_ = other.timeout_ != null ? other.timeout_.Clone() : null;
      MaxRequestMessageBytes = other.MaxRequestMessageBytes;
      MaxResponseMessageBytes = other.MaxResponseMessageBytes;
      switch (other.RetryOrHedgingPolicyCase) {
        case RetryOrHedgingPolicyOneofCase.RetryPolicy:
          RetryPolicy = other.RetryPolicy.Clone();
          break;
        case RetryOrHedgingPolicyOneofCase.HedgingPolicy:
          HedgingPolicy = other.HedgingPolicy.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MethodConfig Clone() {
      return new MethodConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Grpc.ServiceConfig.MethodConfig.Types.Name> _repeated_name_codec
        = pb::FieldCodec.ForMessage(10, global::Grpc.ServiceConfig.MethodConfig.Types.Name.Parser);
    private readonly pbc::RepeatedField<global::Grpc.ServiceConfig.MethodConfig.Types.Name> name_ = new pbc::RepeatedField<global::Grpc.ServiceConfig.MethodConfig.Types.Name>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Grpc.ServiceConfig.MethodConfig.Types.Name> Name {
      get { return name_; }
    }

    /// <summary>Field number for the "wait_for_ready" field.</summary>
    public const int WaitForReadyFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_waitForReady_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? waitForReady_;
    /// <summary>
    /// Whether RPCs sent to this method should wait until the connection is
    /// ready by default. If false, the RPC will abort immediately if there is
    /// a transient failure connecting to the server. Otherwise, gRPC will
    /// attempt to connect until the deadline is exceeded.
    ///
    /// The value specified via the gRPC client API will override the value
    /// set here. However, note that setting the value in the client API will
    /// also affect transient errors encountered during name resolution, which
    /// cannot be caught by the value here, since the service config is
    /// obtained by the gRPC client via name resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? WaitForReady {
      get { return waitForReady_; }
      set {
        waitForReady_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// The default timeout in seconds for RPCs sent to this method. This can be
    /// overridden in code. If no reply is received in the specified amount of
    /// time, the request is aborted and a DEADLINE_EXCEEDED error status
    /// is returned to the caller.
    ///
    /// The actual deadline used will be the minimum of the value specified here
    /// and the value set by the application via the gRPC client API.  If either
    /// one is not set, then the other will be used.  If neither is set, then the
    /// request has no deadline.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "max_request_message_bytes" field.</summary>
    public const int MaxRequestMessageBytesFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestMessageBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? maxRequestMessageBytes_;
    /// <summary>
    /// The maximum allowed payload size for an individual request or object in a
    /// stream (client->server) in bytes. The size which is measured is the
    /// serialized payload after per-message compression (but before stream
    /// compression) in bytes. This applies both to streaming and non-streaming
    /// requests.
    ///
    /// The actual value used is the minumum of the value specified here and the
    /// value set by the application via the gRPC client API.  If either one is
    /// not set, then the other will be used.  If neither is set, then the
    /// built-in default is used.
    ///
    /// If a client attempts to send an object larger than this value, it will not
    /// be sent and the client will see a ClientError.
    /// Note that 0 is a valid value, meaning that the request message
    /// must be empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxRequestMessageBytes {
      get { return maxRequestMessageBytes_; }
      set {
        maxRequestMessageBytes_ = value;
      }
    }

    /// <summary>Field number for the "max_response_message_bytes" field.</summary>
    public const int MaxResponseMessageBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_maxResponseMessageBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? maxResponseMessageBytes_;
    /// <summary>
    /// The maximum allowed payload size for an individual response or object in a
    /// stream (server->client) in bytes. The size which is measured is the
    /// serialized payload after per-message compression (but before stream
    /// compression) in bytes. This applies both to streaming and non-streaming
    /// requests.
    ///
    /// The actual value used is the minumum of the value specified here and the
    /// value set by the application via the gRPC client API.  If either one is
    /// not set, then the other will be used.  If neither is set, then the
    /// built-in default is used.
    ///
    /// If a server attempts to send an object larger than this value, it will not
    /// be sent, and a ServerError will be sent to the client instead.
    /// Note that 0 is a valid value, meaning that the response message
    /// must be empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxResponseMessageBytes {
      get { return maxResponseMessageBytes_; }
      set {
        maxResponseMessageBytes_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy" field.</summary>
    public const int RetryPolicyFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy RetryPolicy {
      get { return retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.RetryPolicy ? (global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy) retryOrHedgingPolicy_ : null; }
      set {
        retryOrHedgingPolicy_ = value;
        retryOrHedgingPolicyCase_ = value == null ? RetryOrHedgingPolicyOneofCase.None : RetryOrHedgingPolicyOneofCase.RetryPolicy;
      }
    }

    /// <summary>Field number for the "hedging_policy" field.</summary>
    public const int HedgingPolicyFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy HedgingPolicy {
      get { return retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.HedgingPolicy ? (global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy) retryOrHedgingPolicy_ : null; }
      set {
        retryOrHedgingPolicy_ = value;
        retryOrHedgingPolicyCase_ = value == null ? RetryOrHedgingPolicyOneofCase.None : RetryOrHedgingPolicyOneofCase.HedgingPolicy;
      }
    }

    private object retryOrHedgingPolicy_;
    /// <summary>Enum of possible cases for the "retry_or_hedging_policy" oneof.</summary>
    public enum RetryOrHedgingPolicyOneofCase {
      None = 0,
      RetryPolicy = 6,
      HedgingPolicy = 7,
    }
    private RetryOrHedgingPolicyOneofCase retryOrHedgingPolicyCase_ = RetryOrHedgingPolicyOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryOrHedgingPolicyOneofCase RetryOrHedgingPolicyCase {
      get { return retryOrHedgingPolicyCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRetryOrHedgingPolicy() {
      retryOrHedgingPolicyCase_ = RetryOrHedgingPolicyOneofCase.None;
      retryOrHedgingPolicy_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MethodConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MethodConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!name_.Equals(other.name_)) return false;
      if (WaitForReady != other.WaitForReady) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if (MaxRequestMessageBytes != other.MaxRequestMessageBytes) return false;
      if (MaxResponseMessageBytes != other.MaxResponseMessageBytes) return false;
      if (!object.Equals(RetryPolicy, other.RetryPolicy)) return false;
      if (!object.Equals(HedgingPolicy, other.HedgingPolicy)) return false;
      if (RetryOrHedgingPolicyCase != other.RetryOrHedgingPolicyCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= name_.GetHashCode();
      if (waitForReady_ != null) hash ^= WaitForReady.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      if (maxRequestMessageBytes_ != null) hash ^= MaxRequestMessageBytes.GetHashCode();
      if (maxResponseMessageBytes_ != null) hash ^= MaxResponseMessageBytes.GetHashCode();
      if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.RetryPolicy) hash ^= RetryPolicy.GetHashCode();
      if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.HedgingPolicy) hash ^= HedgingPolicy.GetHashCode();
      hash ^= (int) retryOrHedgingPolicyCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      name_.WriteTo(output, _repeated_name_codec);
      if (waitForReady_ != null) {
        _single_waitForReady_codec.WriteTagAndValue(output, WaitForReady);
      }
      if (timeout_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Timeout);
      }
      if (maxRequestMessageBytes_ != null) {
        _single_maxRequestMessageBytes_codec.WriteTagAndValue(output, MaxRequestMessageBytes);
      }
      if (maxResponseMessageBytes_ != null) {
        _single_maxResponseMessageBytes_codec.WriteTagAndValue(output, MaxResponseMessageBytes);
      }
      if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.RetryPolicy) {
        output.WriteRawTag(50);
        output.WriteMessage(RetryPolicy);
      }
      if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.HedgingPolicy) {
        output.WriteRawTag(58);
        output.WriteMessage(HedgingPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += name_.CalculateSize(_repeated_name_codec);
      if (waitForReady_ != null) {
        size += _single_waitForReady_codec.CalculateSizeWithTag(WaitForReady);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      if (maxRequestMessageBytes_ != null) {
        size += _single_maxRequestMessageBytes_codec.CalculateSizeWithTag(MaxRequestMessageBytes);
      }
      if (maxResponseMessageBytes_ != null) {
        size += _single_maxResponseMessageBytes_codec.CalculateSizeWithTag(MaxResponseMessageBytes);
      }
      if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.RetryPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicy);
      }
      if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.HedgingPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HedgingPolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MethodConfig other) {
      if (other == null) {
        return;
      }
      name_.Add(other.name_);
      if (other.waitForReady_ != null) {
        if (waitForReady_ == null || other.WaitForReady != false) {
          WaitForReady = other.WaitForReady;
        }
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      if (other.maxRequestMessageBytes_ != null) {
        if (maxRequestMessageBytes_ == null || other.MaxRequestMessageBytes != 0) {
          MaxRequestMessageBytes = other.MaxRequestMessageBytes;
        }
      }
      if (other.maxResponseMessageBytes_ != null) {
        if (maxResponseMessageBytes_ == null || other.MaxResponseMessageBytes != 0) {
          MaxResponseMessageBytes = other.MaxResponseMessageBytes;
        }
      }
      switch (other.RetryOrHedgingPolicyCase) {
        case RetryOrHedgingPolicyOneofCase.RetryPolicy:
          if (RetryPolicy == null) {
            RetryPolicy = new global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy();
          }
          RetryPolicy.MergeFrom(other.RetryPolicy);
          break;
        case RetryOrHedgingPolicyOneofCase.HedgingPolicy:
          if (HedgingPolicy == null) {
            HedgingPolicy = new global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy();
          }
          HedgingPolicy.MergeFrom(other.HedgingPolicy);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            name_.AddEntriesFrom(input, _repeated_name_codec);
            break;
          }
          case 18: {
            bool? value = _single_waitForReady_codec.Read(input);
            if (waitForReady_ == null || value != false) {
              WaitForReady = value;
            }
            break;
          }
          case 26: {
            if (timeout_ == null) {
              timeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(timeout_);
            break;
          }
          case 34: {
            uint? value = _single_maxRequestMessageBytes_codec.Read(input);
            if (maxRequestMessageBytes_ == null || value != 0) {
              MaxRequestMessageBytes = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_maxResponseMessageBytes_codec.Read(input);
            if (maxResponseMessageBytes_ == null || value != 0) {
              MaxResponseMessageBytes = value;
            }
            break;
          }
          case 50: {
            global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy subBuilder = new global::Grpc.ServiceConfig.MethodConfig.Types.RetryPolicy();
            if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.RetryPolicy) {
              subBuilder.MergeFrom(RetryPolicy);
            }
            input.ReadMessage(subBuilder);
            RetryPolicy = subBuilder;
            break;
          }
          case 58: {
            global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy subBuilder = new global::Grpc.ServiceConfig.MethodConfig.Types.HedgingPolicy();
            if (retryOrHedgingPolicyCase_ == RetryOrHedgingPolicyOneofCase.HedgingPolicy) {
              subBuilder.MergeFrom(HedgingPolicy);
            }
            input.ReadMessage(subBuilder);
            HedgingPolicy = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the MethodConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The names of the methods to which this configuration applies. There must
      /// be at least one name. Each name entry must be unique across the entire
      /// ClientConfig. If the 'method' field is empty, then this MethodConfig
      /// specifies the defaults for all methods for the specified service.
      ///
      /// For example, let's say that the service config contains the following
      /// MethodConfig entries:
      ///
      /// method_config { name { service: "MyService" } ... }
      /// method_config { name { service: "MyService" method: "Foo" } ... }
      ///
      /// For a request for MyService/Foo, we will use the second entry, because it
      /// exactly matches the service and method name.
      /// For a request for MyService/Bar, we will use the first entry, because it
      /// provides the default for all methods of MyService.
      /// </summary>
      public sealed partial class Name : pb::IMessage<Name> {
        private static readonly pb::MessageParser<Name> _parser = new pb::MessageParser<Name>(() => new Name());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Name> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Grpc.ServiceConfig.MethodConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Name() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Name(Name other) : this() {
          service_ = other.service_;
          method_ = other.method_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Name Clone() {
          return new Name(this);
        }

        /// <summary>Field number for the "service" field.</summary>
        public const int ServiceFieldNumber = 1;
        private string service_ = "";
        /// <summary>
        /// Required. Includes proto package name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Service {
          get { return service_; }
          set {
            service_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "method" field.</summary>
        public const int MethodFieldNumber = 2;
        private string method_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Method {
          get { return method_; }
          set {
            method_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Name);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Name other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Service != other.Service) return false;
          if (Method != other.Method) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Service.Length != 0) hash ^= Service.GetHashCode();
          if (Method.Length != 0) hash ^= Method.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Service.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Service);
          }
          if (Method.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Method);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Service.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Service);
          }
          if (Method.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Method);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Name other) {
          if (other == null) {
            return;
          }
          if (other.Service.Length != 0) {
            Service = other.Service;
          }
          if (other.Method.Length != 0) {
            Method = other.Method;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Service = input.ReadString();
                break;
              }
              case 18: {
                Method = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The retry policy for outgoing RPCs.
      /// </summary>
      public sealed partial class RetryPolicy : pb::IMessage<RetryPolicy> {
        private static readonly pb::MessageParser<RetryPolicy> _parser = new pb::MessageParser<RetryPolicy>(() => new RetryPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RetryPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Grpc.ServiceConfig.MethodConfig.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPolicy(RetryPolicy other) : this() {
          maxAttempts_ = other.maxAttempts_;
          initialBackoff_ = other.initialBackoff_ != null ? other.initialBackoff_.Clone() : null;
          maxBackoff_ = other.maxBackoff_ != null ? other.maxBackoff_.Clone() : null;
          backoffMultiplier_ = other.backoffMultiplier_;
          retryableStatusCodes_ = other.retryableStatusCodes_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPolicy Clone() {
          return new RetryPolicy(this);
        }

        /// <summary>Field number for the "max_attempts" field.</summary>
        public const int MaxAttemptsFieldNumber = 1;
        private uint maxAttempts_;
        /// <summary>
        /// The maximum number of RPC attempts, including the original attempt.
        ///
        /// This field is required and must be greater than 1.
        /// Any value greater than 5 will be treated as if it were 5.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint MaxAttempts {
          get { return maxAttempts_; }
          set {
            maxAttempts_ = value;
          }
        }

        /// <summary>Field number for the "initial_backoff" field.</summary>
        public const int InitialBackoffFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration initialBackoff_;
        /// <summary>
        /// Exponential backoff parameters. The initial retry attempt will occur at
        /// random(0, initial_backoff). In general, the nth attempt will occur at
        /// random(0,
        ///   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
        /// Required. Must be greater than zero.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration InitialBackoff {
          get { return initialBackoff_; }
          set {
            initialBackoff_ = value;
          }
        }

        /// <summary>Field number for the "max_backoff" field.</summary>
        public const int MaxBackoffFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Duration maxBackoff_;
        /// <summary>
        /// Required. Must be greater than zero.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxBackoff {
          get { return maxBackoff_; }
          set {
            maxBackoff_ = value;
          }
        }

        /// <summary>Field number for the "backoff_multiplier" field.</summary>
        public const int BackoffMultiplierFieldNumber = 4;
        private float backoffMultiplier_;
        /// <summary>
        /// Required. Must be greater than zero.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float BackoffMultiplier {
          get { return backoffMultiplier_; }
          set {
            backoffMultiplier_ = value;
          }
        }

        /// <summary>Field number for the "retryable_status_codes" field.</summary>
        public const int RetryableStatusCodesFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Google.Rpc.Code> _repeated_retryableStatusCodes_codec
            = pb::FieldCodec.ForEnum(42, x => (int) x, x => (global::Google.Rpc.Code) x);
        private readonly pbc::RepeatedField<global::Google.Rpc.Code> retryableStatusCodes_ = new pbc::RepeatedField<global::Google.Rpc.Code>();
        /// <summary>
        /// The set of status codes which may be retried.
        ///
        /// This field is required and must be non-empty.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Rpc.Code> RetryableStatusCodes {
          get { return retryableStatusCodes_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RetryPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RetryPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxAttempts != other.MaxAttempts) return false;
          if (!object.Equals(InitialBackoff, other.InitialBackoff)) return false;
          if (!object.Equals(MaxBackoff, other.MaxBackoff)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BackoffMultiplier, other.BackoffMultiplier)) return false;
          if(!retryableStatusCodes_.Equals(other.retryableStatusCodes_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (MaxAttempts != 0) hash ^= MaxAttempts.GetHashCode();
          if (initialBackoff_ != null) hash ^= InitialBackoff.GetHashCode();
          if (maxBackoff_ != null) hash ^= MaxBackoff.GetHashCode();
          if (BackoffMultiplier != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BackoffMultiplier);
          hash ^= retryableStatusCodes_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (MaxAttempts != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(MaxAttempts);
          }
          if (initialBackoff_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(InitialBackoff);
          }
          if (maxBackoff_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MaxBackoff);
          }
          if (BackoffMultiplier != 0F) {
            output.WriteRawTag(37);
            output.WriteFloat(BackoffMultiplier);
          }
          retryableStatusCodes_.WriteTo(output, _repeated_retryableStatusCodes_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (MaxAttempts != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxAttempts);
          }
          if (initialBackoff_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialBackoff);
          }
          if (maxBackoff_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxBackoff);
          }
          if (BackoffMultiplier != 0F) {
            size += 1 + 4;
          }
          size += retryableStatusCodes_.CalculateSize(_repeated_retryableStatusCodes_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RetryPolicy other) {
          if (other == null) {
            return;
          }
          if (other.MaxAttempts != 0) {
            MaxAttempts = other.MaxAttempts;
          }
          if (other.initialBackoff_ != null) {
            if (initialBackoff_ == null) {
              initialBackoff_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            InitialBackoff.MergeFrom(other.InitialBackoff);
          }
          if (other.maxBackoff_ != null) {
            if (maxBackoff_ == null) {
              maxBackoff_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxBackoff.MergeFrom(other.MaxBackoff);
          }
          if (other.BackoffMultiplier != 0F) {
            BackoffMultiplier = other.BackoffMultiplier;
          }
          retryableStatusCodes_.Add(other.retryableStatusCodes_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxAttempts = input.ReadUInt32();
                break;
              }
              case 18: {
                if (initialBackoff_ == null) {
                  initialBackoff_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(initialBackoff_);
                break;
              }
              case 26: {
                if (maxBackoff_ == null) {
                  maxBackoff_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(maxBackoff_);
                break;
              }
              case 37: {
                BackoffMultiplier = input.ReadFloat();
                break;
              }
              case 42:
              case 40: {
                retryableStatusCodes_.AddEntriesFrom(input, _repeated_retryableStatusCodes_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The hedging policy for outgoing RPCs. Hedged RPCs may execute more than
      /// once on the server, so only idempotent methods should specify a hedging
      /// policy.
      /// </summary>
      public sealed partial class HedgingPolicy : pb::IMessage<HedgingPolicy> {
        private static readonly pb::MessageParser<HedgingPolicy> _parser = new pb::MessageParser<HedgingPolicy>(() => new HedgingPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HedgingPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Grpc.ServiceConfig.MethodConfig.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HedgingPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HedgingPolicy(HedgingPolicy other) : this() {
          maxAttempts_ = other.maxAttempts_;
          hedgingDelay_ = other.hedgingDelay_ != null ? other.hedgingDelay_.Clone() : null;
          nonFatalStatusCodes_ = other.nonFatalStatusCodes_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HedgingPolicy Clone() {
          return new HedgingPolicy(this);
        }

        /// <summary>Field number for the "max_attempts" field.</summary>
        public const int MaxAttemptsFieldNumber = 1;
        private uint maxAttempts_;
        /// <summary>
        /// The hedging policy will send up to max_requests RPCs.
        /// This number represents the total number of all attempts, including
        /// the original attempt.
        ///
        /// This field is required and must be greater than 1.
        /// Any value greater than 5 will be treated as if it were 5.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint MaxAttempts {
          get { return maxAttempts_; }
          set {
            maxAttempts_ = value;
          }
        }

        /// <summary>Field number for the "hedging_delay" field.</summary>
        public const int HedgingDelayFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration hedgingDelay_;
        /// <summary>
        /// The first RPC will be sent immediately, but the max_requests-1 subsequent
        /// hedged RPCs will be sent at intervals of every hedging_delay. Set this
        /// to 0 to immediately send all max_requests RPCs.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration HedgingDelay {
          get { return hedgingDelay_; }
          set {
            hedgingDelay_ = value;
          }
        }

        /// <summary>Field number for the "non_fatal_status_codes" field.</summary>
        public const int NonFatalStatusCodesFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Google.Rpc.Code> _repeated_nonFatalStatusCodes_codec
            = pb::FieldCodec.ForEnum(26, x => (int) x, x => (global::Google.Rpc.Code) x);
        private readonly pbc::RepeatedField<global::Google.Rpc.Code> nonFatalStatusCodes_ = new pbc::RepeatedField<global::Google.Rpc.Code>();
        /// <summary>
        /// The set of status codes which indicate other hedged RPCs may still
        /// succeed. If a non-fatal status code is returned by the server, hedged
        /// RPCs will continue. Otherwise, outstanding requests will be canceled and
        /// the error returned to the client application layer.
        ///
        /// This field is optional.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Rpc.Code> NonFatalStatusCodes {
          get { return nonFatalStatusCodes_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HedgingPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HedgingPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxAttempts != other.MaxAttempts) return false;
          if (!object.Equals(HedgingDelay, other.HedgingDelay)) return false;
          if(!nonFatalStatusCodes_.Equals(other.nonFatalStatusCodes_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (MaxAttempts != 0) hash ^= MaxAttempts.GetHashCode();
          if (hedgingDelay_ != null) hash ^= HedgingDelay.GetHashCode();
          hash ^= nonFatalStatusCodes_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (MaxAttempts != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(MaxAttempts);
          }
          if (hedgingDelay_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(HedgingDelay);
          }
          nonFatalStatusCodes_.WriteTo(output, _repeated_nonFatalStatusCodes_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (MaxAttempts != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxAttempts);
          }
          if (hedgingDelay_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HedgingDelay);
          }
          size += nonFatalStatusCodes_.CalculateSize(_repeated_nonFatalStatusCodes_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HedgingPolicy other) {
          if (other == null) {
            return;
          }
          if (other.MaxAttempts != 0) {
            MaxAttempts = other.MaxAttempts;
          }
          if (other.hedgingDelay_ != null) {
            if (hedgingDelay_ == null) {
              hedgingDelay_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            HedgingDelay.MergeFrom(other.HedgingDelay);
          }
          nonFatalStatusCodes_.Add(other.nonFatalStatusCodes_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxAttempts = input.ReadUInt32();
                break;
              }
              case 18: {
                if (hedgingDelay_ == null) {
                  hedgingDelay_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(hedgingDelay_);
                break;
              }
              case 26:
              case 24: {
                nonFatalStatusCodes_.AddEntriesFrom(input, _repeated_nonFatalStatusCodes_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration for pick_first LB policy.
  /// </summary>
  public sealed partial class PickFirstConfig : pb::IMessage<PickFirstConfig> {
    private static readonly pb::MessageParser<PickFirstConfig> _parser = new pb::MessageParser<PickFirstConfig>(() => new PickFirstConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickFirstConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickFirstConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickFirstConfig(PickFirstConfig other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickFirstConfig Clone() {
      return new PickFirstConfig(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickFirstConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickFirstConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickFirstConfig other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Configuration for round_robin LB policy.
  /// </summary>
  public sealed partial class RoundRobinConfig : pb::IMessage<RoundRobinConfig> {
    private static readonly pb::MessageParser<RoundRobinConfig> _parser = new pb::MessageParser<RoundRobinConfig>(() => new RoundRobinConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RoundRobinConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoundRobinConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoundRobinConfig(RoundRobinConfig other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoundRobinConfig Clone() {
      return new RoundRobinConfig(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RoundRobinConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RoundRobinConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RoundRobinConfig other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Configuration for grpclb LB policy.
  /// </summary>
  public sealed partial class GrpcLbConfig : pb::IMessage<GrpcLbConfig> {
    private static readonly pb::MessageParser<GrpcLbConfig> _parser = new pb::MessageParser<GrpcLbConfig>(() => new GrpcLbConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GrpcLbConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GrpcLbConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GrpcLbConfig(GrpcLbConfig other) : this() {
      childPolicy_ = other.childPolicy_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GrpcLbConfig Clone() {
      return new GrpcLbConfig(this);
    }

    /// <summary>Field number for the "child_policy" field.</summary>
    public const int ChildPolicyFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Grpc.ServiceConfig.LoadBalancingConfig> _repeated_childPolicy_codec
        = pb::FieldCodec.ForMessage(10, global::Grpc.ServiceConfig.LoadBalancingConfig.Parser);
    private readonly pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> childPolicy_ = new pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig>();
    /// <summary>
    /// Optional.  What LB policy to use for routing between the backend
    /// addresses.  If unset, defaults to round_robin.
    /// Currently, the only supported values are round_robin and pick_first.
    /// Note that this will be used both in balancer mode and in fallback mode.
    /// Multiple LB policies can be specified; clients will iterate through
    /// the list in order and stop at the first policy that they support.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> ChildPolicy {
      get { return childPolicy_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GrpcLbConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GrpcLbConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!childPolicy_.Equals(other.childPolicy_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= childPolicy_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      childPolicy_.WriteTo(output, _repeated_childPolicy_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += childPolicy_.CalculateSize(_repeated_childPolicy_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GrpcLbConfig other) {
      if (other == null) {
        return;
      }
      childPolicy_.Add(other.childPolicy_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            childPolicy_.AddEntriesFrom(input, _repeated_childPolicy_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for xds LB policy.
  /// </summary>
  public sealed partial class XdsConfig : pb::IMessage<XdsConfig> {
    private static readonly pb::MessageParser<XdsConfig> _parser = new pb::MessageParser<XdsConfig>(() => new XdsConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<XdsConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XdsConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XdsConfig(XdsConfig other) : this() {
      balancerName_ = other.balancerName_;
      childPolicy_ = other.childPolicy_.Clone();
      fallbackPolicy_ = other.fallbackPolicy_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public XdsConfig Clone() {
      return new XdsConfig(this);
    }

    /// <summary>Field number for the "balancer_name" field.</summary>
    public const int BalancerNameFieldNumber = 1;
    private string balancerName_ = "";
    /// <summary>
    /// Required.  Name of balancer to connect to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BalancerName {
      get { return balancerName_; }
      set {
        balancerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "child_policy" field.</summary>
    public const int ChildPolicyFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Grpc.ServiceConfig.LoadBalancingConfig> _repeated_childPolicy_codec
        = pb::FieldCodec.ForMessage(18, global::Grpc.ServiceConfig.LoadBalancingConfig.Parser);
    private readonly pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> childPolicy_ = new pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig>();
    /// <summary>
    /// Optional.  What LB policy to use for intra-locality routing.
    /// If unset, will use whatever algorithm is specified by the balancer.
    /// Multiple LB policies can be specified; clients will iterate through
    /// the list in order and stop at the first policy that they support.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> ChildPolicy {
      get { return childPolicy_; }
    }

    /// <summary>Field number for the "fallback_policy" field.</summary>
    public const int FallbackPolicyFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Grpc.ServiceConfig.LoadBalancingConfig> _repeated_fallbackPolicy_codec
        = pb::FieldCodec.ForMessage(26, global::Grpc.ServiceConfig.LoadBalancingConfig.Parser);
    private readonly pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> fallbackPolicy_ = new pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig>();
    /// <summary>
    /// Optional.  What LB policy to use in fallback mode.  If not
    /// specified, defaults to round_robin.
    /// Multiple LB policies can be specified; clients will iterate through
    /// the list in order and stop at the first policy that they support.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> FallbackPolicy {
      get { return fallbackPolicy_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as XdsConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(XdsConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BalancerName != other.BalancerName) return false;
      if(!childPolicy_.Equals(other.childPolicy_)) return false;
      if(!fallbackPolicy_.Equals(other.fallbackPolicy_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BalancerName.Length != 0) hash ^= BalancerName.GetHashCode();
      hash ^= childPolicy_.GetHashCode();
      hash ^= fallbackPolicy_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (BalancerName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BalancerName);
      }
      childPolicy_.WriteTo(output, _repeated_childPolicy_codec);
      fallbackPolicy_.WriteTo(output, _repeated_fallbackPolicy_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BalancerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BalancerName);
      }
      size += childPolicy_.CalculateSize(_repeated_childPolicy_codec);
      size += fallbackPolicy_.CalculateSize(_repeated_fallbackPolicy_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(XdsConfig other) {
      if (other == null) {
        return;
      }
      if (other.BalancerName.Length != 0) {
        BalancerName = other.BalancerName;
      }
      childPolicy_.Add(other.childPolicy_);
      fallbackPolicy_.Add(other.fallbackPolicy_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            BalancerName = input.ReadString();
            break;
          }
          case 18: {
            childPolicy_.AddEntriesFrom(input, _repeated_childPolicy_codec);
            break;
          }
          case 26: {
            fallbackPolicy_.AddEntriesFrom(input, _repeated_fallbackPolicy_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Selects LB policy and provides corresponding configuration.
  ///
  /// In general, all instances of this field should be repeated.
  /// Clients will iterate through the list in order and stop at the first
  /// policy that they support.  This allows the service config to specify
  /// custom policies that may not be known to all clients.
  /// </summary>
  public sealed partial class LoadBalancingConfig : pb::IMessage<LoadBalancingConfig> {
    private static readonly pb::MessageParser<LoadBalancingConfig> _parser = new pb::MessageParser<LoadBalancingConfig>(() => new LoadBalancingConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LoadBalancingConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoadBalancingConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoadBalancingConfig(LoadBalancingConfig other) : this() {
      switch (other.PolicyCase) {
        case PolicyOneofCase.PickFirst:
          PickFirst = other.PickFirst.Clone();
          break;
        case PolicyOneofCase.RoundRobin:
          RoundRobin = other.RoundRobin.Clone();
          break;
        case PolicyOneofCase.Grpclb:
          Grpclb = other.Grpclb.Clone();
          break;
        case PolicyOneofCase.Xds:
          Xds = other.Xds.Clone();
          break;
        case PolicyOneofCase.XdsExperimental:
          XdsExperimental = other.XdsExperimental.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoadBalancingConfig Clone() {
      return new LoadBalancingConfig(this);
    }

    /// <summary>Field number for the "pick_first" field.</summary>
    public const int PickFirstFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.PickFirstConfig PickFirst {
      get { return policyCase_ == PolicyOneofCase.PickFirst ? (global::Grpc.ServiceConfig.PickFirstConfig) policy_ : null; }
      set {
        policy_ = value;
        policyCase_ = value == null ? PolicyOneofCase.None : PolicyOneofCase.PickFirst;
      }
    }

    /// <summary>Field number for the "round_robin" field.</summary>
    public const int RoundRobinFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.RoundRobinConfig RoundRobin {
      get { return policyCase_ == PolicyOneofCase.RoundRobin ? (global::Grpc.ServiceConfig.RoundRobinConfig) policy_ : null; }
      set {
        policy_ = value;
        policyCase_ = value == null ? PolicyOneofCase.None : PolicyOneofCase.RoundRobin;
      }
    }

    /// <summary>Field number for the "grpclb" field.</summary>
    public const int GrpclbFieldNumber = 3;
    /// <summary>
    /// gRPC lookaside load balancing.
    /// This will eventually be deprecated by the new xDS-based local
    /// balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.GrpcLbConfig Grpclb {
      get { return policyCase_ == PolicyOneofCase.Grpclb ? (global::Grpc.ServiceConfig.GrpcLbConfig) policy_ : null; }
      set {
        policy_ = value;
        policyCase_ = value == null ? PolicyOneofCase.None : PolicyOneofCase.Grpclb;
      }
    }

    /// <summary>Field number for the "xds" field.</summary>
    public const int XdsFieldNumber = 2;
    /// <summary>
    /// EXPERIMENTAL -- DO NOT USE
    /// xDS-based load balancing.
    /// The policy is known as xds_experimental while it is under development.
    /// It will be renamed to xds once it is ready for public use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.XdsConfig Xds {
      get { return policyCase_ == PolicyOneofCase.Xds ? (global::Grpc.ServiceConfig.XdsConfig) policy_ : null; }
      set {
        policy_ = value;
        policyCase_ = value == null ? PolicyOneofCase.None : PolicyOneofCase.Xds;
      }
    }

    /// <summary>Field number for the "xds_experimental" field.</summary>
    public const int XdsExperimentalFieldNumber = 5;
    /// <summary>
    /// TODO(rekarthik): Deprecate this field after the xds policy
    /// is ready for public use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.XdsConfig XdsExperimental {
      get { return policyCase_ == PolicyOneofCase.XdsExperimental ? (global::Grpc.ServiceConfig.XdsConfig) policy_ : null; }
      set {
        policy_ = value;
        policyCase_ = value == null ? PolicyOneofCase.None : PolicyOneofCase.XdsExperimental;
      }
    }

    private object policy_;
    /// <summary>Enum of possible cases for the "policy" oneof.</summary>
    public enum PolicyOneofCase {
      None = 0,
      PickFirst = 4,
      RoundRobin = 1,
      Grpclb = 3,
      Xds = 2,
      XdsExperimental = 5,
    }
    private PolicyOneofCase policyCase_ = PolicyOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PolicyOneofCase PolicyCase {
      get { return policyCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPolicy() {
      policyCase_ = PolicyOneofCase.None;
      policy_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LoadBalancingConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LoadBalancingConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PickFirst, other.PickFirst)) return false;
      if (!object.Equals(RoundRobin, other.RoundRobin)) return false;
      if (!object.Equals(Grpclb, other.Grpclb)) return false;
      if (!object.Equals(Xds, other.Xds)) return false;
      if (!object.Equals(XdsExperimental, other.XdsExperimental)) return false;
      if (PolicyCase != other.PolicyCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (policyCase_ == PolicyOneofCase.PickFirst) hash ^= PickFirst.GetHashCode();
      if (policyCase_ == PolicyOneofCase.RoundRobin) hash ^= RoundRobin.GetHashCode();
      if (policyCase_ == PolicyOneofCase.Grpclb) hash ^= Grpclb.GetHashCode();
      if (policyCase_ == PolicyOneofCase.Xds) hash ^= Xds.GetHashCode();
      if (policyCase_ == PolicyOneofCase.XdsExperimental) hash ^= XdsExperimental.GetHashCode();
      hash ^= (int) policyCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (policyCase_ == PolicyOneofCase.RoundRobin) {
        output.WriteRawTag(10);
        output.WriteMessage(RoundRobin);
      }
      if (policyCase_ == PolicyOneofCase.Xds) {
        output.WriteRawTag(18);
        output.WriteMessage(Xds);
      }
      if (policyCase_ == PolicyOneofCase.Grpclb) {
        output.WriteRawTag(26);
        output.WriteMessage(Grpclb);
      }
      if (policyCase_ == PolicyOneofCase.PickFirst) {
        output.WriteRawTag(34);
        output.WriteMessage(PickFirst);
      }
      if (policyCase_ == PolicyOneofCase.XdsExperimental) {
        output.WriteRawTag(42);
        output.WriteMessage(XdsExperimental);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (policyCase_ == PolicyOneofCase.PickFirst) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickFirst);
      }
      if (policyCase_ == PolicyOneofCase.RoundRobin) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoundRobin);
      }
      if (policyCase_ == PolicyOneofCase.Grpclb) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Grpclb);
      }
      if (policyCase_ == PolicyOneofCase.Xds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Xds);
      }
      if (policyCase_ == PolicyOneofCase.XdsExperimental) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(XdsExperimental);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LoadBalancingConfig other) {
      if (other == null) {
        return;
      }
      switch (other.PolicyCase) {
        case PolicyOneofCase.PickFirst:
          if (PickFirst == null) {
            PickFirst = new global::Grpc.ServiceConfig.PickFirstConfig();
          }
          PickFirst.MergeFrom(other.PickFirst);
          break;
        case PolicyOneofCase.RoundRobin:
          if (RoundRobin == null) {
            RoundRobin = new global::Grpc.ServiceConfig.RoundRobinConfig();
          }
          RoundRobin.MergeFrom(other.RoundRobin);
          break;
        case PolicyOneofCase.Grpclb:
          if (Grpclb == null) {
            Grpclb = new global::Grpc.ServiceConfig.GrpcLbConfig();
          }
          Grpclb.MergeFrom(other.Grpclb);
          break;
        case PolicyOneofCase.Xds:
          if (Xds == null) {
            Xds = new global::Grpc.ServiceConfig.XdsConfig();
          }
          Xds.MergeFrom(other.Xds);
          break;
        case PolicyOneofCase.XdsExperimental:
          if (XdsExperimental == null) {
            XdsExperimental = new global::Grpc.ServiceConfig.XdsConfig();
          }
          XdsExperimental.MergeFrom(other.XdsExperimental);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Grpc.ServiceConfig.RoundRobinConfig subBuilder = new global::Grpc.ServiceConfig.RoundRobinConfig();
            if (policyCase_ == PolicyOneofCase.RoundRobin) {
              subBuilder.MergeFrom(RoundRobin);
            }
            input.ReadMessage(subBuilder);
            RoundRobin = subBuilder;
            break;
          }
          case 18: {
            global::Grpc.ServiceConfig.XdsConfig subBuilder = new global::Grpc.ServiceConfig.XdsConfig();
            if (policyCase_ == PolicyOneofCase.Xds) {
              subBuilder.MergeFrom(Xds);
            }
            input.ReadMessage(subBuilder);
            Xds = subBuilder;
            break;
          }
          case 26: {
            global::Grpc.ServiceConfig.GrpcLbConfig subBuilder = new global::Grpc.ServiceConfig.GrpcLbConfig();
            if (policyCase_ == PolicyOneofCase.Grpclb) {
              subBuilder.MergeFrom(Grpclb);
            }
            input.ReadMessage(subBuilder);
            Grpclb = subBuilder;
            break;
          }
          case 34: {
            global::Grpc.ServiceConfig.PickFirstConfig subBuilder = new global::Grpc.ServiceConfig.PickFirstConfig();
            if (policyCase_ == PolicyOneofCase.PickFirst) {
              subBuilder.MergeFrom(PickFirst);
            }
            input.ReadMessage(subBuilder);
            PickFirst = subBuilder;
            break;
          }
          case 42: {
            global::Grpc.ServiceConfig.XdsConfig subBuilder = new global::Grpc.ServiceConfig.XdsConfig();
            if (policyCase_ == PolicyOneofCase.XdsExperimental) {
              subBuilder.MergeFrom(XdsExperimental);
            }
            input.ReadMessage(subBuilder);
            XdsExperimental = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A ServiceConfig represents information about a service but is not specific to
  /// any name resolver.
  /// </summary>
  public sealed partial class ServiceConfig : pb::IMessage<ServiceConfig> {
    private static readonly pb::MessageParser<ServiceConfig> _parser = new pb::MessageParser<ServiceConfig>(() => new ServiceConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ServiceConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Grpc.ServiceConfig.ServiceConfigReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServiceConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServiceConfig(ServiceConfig other) : this() {
      loadBalancingPolicy_ = other.loadBalancingPolicy_;
      loadBalancingConfig_ = other.loadBalancingConfig_.Clone();
      methodConfig_ = other.methodConfig_.Clone();
      retryThrottling_ = other.retryThrottling_ != null ? other.retryThrottling_.Clone() : null;
      healthCheckConfig_ = other.healthCheckConfig_ != null ? other.healthCheckConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ServiceConfig Clone() {
      return new ServiceConfig(this);
    }

    /// <summary>Field number for the "load_balancing_policy" field.</summary>
    public const int LoadBalancingPolicyFieldNumber = 1;
    private global::Grpc.ServiceConfig.ServiceConfig.Types.LoadBalancingPolicy loadBalancingPolicy_ = 0;
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.ServiceConfig.Types.LoadBalancingPolicy LoadBalancingPolicy {
      get { return loadBalancingPolicy_; }
      set {
        loadBalancingPolicy_ = value;
      }
    }

    /// <summary>Field number for the "load_balancing_config" field.</summary>
    public const int LoadBalancingConfigFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Grpc.ServiceConfig.LoadBalancingConfig> _repeated_loadBalancingConfig_codec
        = pb::FieldCodec.ForMessage(34, global::Grpc.ServiceConfig.LoadBalancingConfig.Parser);
    private readonly pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> loadBalancingConfig_ = new pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig>();
    /// <summary>
    /// Multiple LB policies can be specified; clients will iterate through
    /// the list in order and stop at the first policy that they support. If none
    /// are supported, the service config is considered invalid.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Grpc.ServiceConfig.LoadBalancingConfig> LoadBalancingConfig {
      get { return loadBalancingConfig_; }
    }

    /// <summary>Field number for the "method_config" field.</summary>
    public const int MethodConfigFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Grpc.ServiceConfig.MethodConfig> _repeated_methodConfig_codec
        = pb::FieldCodec.ForMessage(18, global::Grpc.ServiceConfig.MethodConfig.Parser);
    private readonly pbc::RepeatedField<global::Grpc.ServiceConfig.MethodConfig> methodConfig_ = new pbc::RepeatedField<global::Grpc.ServiceConfig.MethodConfig>();
    /// <summary>
    /// Per-method configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Grpc.ServiceConfig.MethodConfig> MethodConfig {
      get { return methodConfig_; }
    }

    /// <summary>Field number for the "retry_throttling" field.</summary>
    public const int RetryThrottlingFieldNumber = 3;
    private global::Grpc.ServiceConfig.ServiceConfig.Types.RetryThrottlingPolicy retryThrottling_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.ServiceConfig.Types.RetryThrottlingPolicy RetryThrottling {
      get { return retryThrottling_; }
      set {
        retryThrottling_ = value;
      }
    }

    /// <summary>Field number for the "health_check_config" field.</summary>
    public const int HealthCheckConfigFieldNumber = 5;
    private global::Grpc.ServiceConfig.ServiceConfig.Types.HealthCheckConfig healthCheckConfig_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Grpc.ServiceConfig.ServiceConfig.Types.HealthCheckConfig HealthCheckConfig {
      get { return healthCheckConfig_; }
      set {
        healthCheckConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ServiceConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ServiceConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LoadBalancingPolicy != other.LoadBalancingPolicy) return false;
      if(!loadBalancingConfig_.Equals(other.loadBalancingConfig_)) return false;
      if(!methodConfig_.Equals(other.methodConfig_)) return false;
      if (!object.Equals(RetryThrottling, other.RetryThrottling)) return false;
      if (!object.Equals(HealthCheckConfig, other.HealthCheckConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (LoadBalancingPolicy != 0) hash ^= LoadBalancingPolicy.GetHashCode();
      hash ^= loadBalancingConfig_.GetHashCode();
      hash ^= methodConfig_.GetHashCode();
      if (retryThrottling_ != null) hash ^= RetryThrottling.GetHashCode();
      if (healthCheckConfig_ != null) hash ^= HealthCheckConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LoadBalancingPolicy != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LoadBalancingPolicy);
      }
      methodConfig_.WriteTo(output, _repeated_methodConfig_codec);
      if (retryThrottling_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RetryThrottling);
      }
      loadBalancingConfig_.WriteTo(output, _repeated_loadBalancingConfig_codec);
      if (healthCheckConfig_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(HealthCheckConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (LoadBalancingPolicy != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LoadBalancingPolicy);
      }
      size += loadBalancingConfig_.CalculateSize(_repeated_loadBalancingConfig_codec);
      size += methodConfig_.CalculateSize(_repeated_methodConfig_codec);
      if (retryThrottling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryThrottling);
      }
      if (healthCheckConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HealthCheckConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ServiceConfig other) {
      if (other == null) {
        return;
      }
      if (other.LoadBalancingPolicy != 0) {
        LoadBalancingPolicy = other.LoadBalancingPolicy;
      }
      loadBalancingConfig_.Add(other.loadBalancingConfig_);
      methodConfig_.Add(other.methodConfig_);
      if (other.retryThrottling_ != null) {
        if (retryThrottling_ == null) {
          retryThrottling_ = new global::Grpc.ServiceConfig.ServiceConfig.Types.RetryThrottlingPolicy();
        }
        RetryThrottling.MergeFrom(other.RetryThrottling);
      }
      if (other.healthCheckConfig_ != null) {
        if (healthCheckConfig_ == null) {
          healthCheckConfig_ = new global::Grpc.ServiceConfig.ServiceConfig.Types.HealthCheckConfig();
        }
        HealthCheckConfig.MergeFrom(other.HealthCheckConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            loadBalancingPolicy_ = (global::Grpc.ServiceConfig.ServiceConfig.Types.LoadBalancingPolicy) input.ReadEnum();
            break;
          }
          case 18: {
            methodConfig_.AddEntriesFrom(input, _repeated_methodConfig_codec);
            break;
          }
          case 26: {
            if (retryThrottling_ == null) {
              retryThrottling_ = new global::Grpc.ServiceConfig.ServiceConfig.Types.RetryThrottlingPolicy();
            }
            input.ReadMessage(retryThrottling_);
            break;
          }
          case 34: {
            loadBalancingConfig_.AddEntriesFrom(input, _repeated_loadBalancingConfig_codec);
            break;
          }
          case 42: {
            if (healthCheckConfig_ == null) {
              healthCheckConfig_ = new global::Grpc.ServiceConfig.ServiceConfig.Types.HealthCheckConfig();
            }
            input.ReadMessage(healthCheckConfig_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ServiceConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Load balancing policy.
      ///
      /// Note that load_balancing_policy is deprecated in favor of
      /// load_balancing_config; the former will be used only if the latter
      /// is unset.
      ///
      /// If no LB policy is configured here, then the default is pick_first.
      /// If the policy name is set via the client API, that value overrides
      /// the value specified here.
      ///
      /// If the deprecated load_balancing_policy field is used, note that if the
      /// resolver returns at least one balancer address (as opposed to backend
      /// addresses), gRPC will use grpclb (see
      /// https://github.com/grpc/grpc/blob/master/doc/load-balancing.md),
      /// regardless of what policy is configured here.  However, if the resolver
      /// returns at least one backend address in addition to the balancer
      /// address(es), the client may fall back to the requested policy if it
      /// is unable to reach any of the grpclb load balancers.
      /// </summary>
      public enum LoadBalancingPolicy {
        [pbr::OriginalName("UNSPECIFIED")] Unspecified = 0,
        [pbr::OriginalName("ROUND_ROBIN")] RoundRobin = 1,
      }

      /// <summary>
      /// If a RetryThrottlingPolicy is provided, gRPC will automatically throttle
      /// retry attempts and hedged RPCs when the client's ratio of failures to
      /// successes exceeds a threshold.
      ///
      /// For each server name, the gRPC client will maintain a token_count which is
      /// initially set to max_tokens. Every outgoing RPC (regardless of service or
      /// method invoked) will change token_count as follows:
      ///
      ///   - Every failed RPC will decrement the token_count by 1.
      ///   - Every successful RPC will increment the token_count by token_ratio.
      ///
      /// If token_count is less than or equal to max_tokens / 2, then RPCs will not
      /// be retried and hedged RPCs will not be sent.
      /// </summary>
      public sealed partial class RetryThrottlingPolicy : pb::IMessage<RetryThrottlingPolicy> {
        private static readonly pb::MessageParser<RetryThrottlingPolicy> _parser = new pb::MessageParser<RetryThrottlingPolicy>(() => new RetryThrottlingPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RetryThrottlingPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Grpc.ServiceConfig.ServiceConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryThrottlingPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryThrottlingPolicy(RetryThrottlingPolicy other) : this() {
          maxTokens_ = other.maxTokens_;
          tokenRatio_ = other.tokenRatio_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryThrottlingPolicy Clone() {
          return new RetryThrottlingPolicy(this);
        }

        /// <summary>Field number for the "max_tokens" field.</summary>
        public const int MaxTokensFieldNumber = 1;
        private uint maxTokens_;
        /// <summary>
        /// The number of tokens starts at max_tokens. The token_count will always be
        /// between 0 and max_tokens.
        ///
        /// This field is required and must be greater than zero.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint MaxTokens {
          get { return maxTokens_; }
          set {
            maxTokens_ = value;
          }
        }

        /// <summary>Field number for the "token_ratio" field.</summary>
        public const int TokenRatioFieldNumber = 2;
        private float tokenRatio_;
        /// <summary>
        /// The amount of tokens to add on each successful RPC. Typically this will
        /// be some number between 0 and 1, e.g., 0.1.
        ///
        /// This field is required and must be greater than zero. Up to 3 decimal
        /// places are supported.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float TokenRatio {
          get { return tokenRatio_; }
          set {
            tokenRatio_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RetryThrottlingPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RetryThrottlingPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxTokens != other.MaxTokens) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TokenRatio, other.TokenRatio)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (MaxTokens != 0) hash ^= MaxTokens.GetHashCode();
          if (TokenRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TokenRatio);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (MaxTokens != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(MaxTokens);
          }
          if (TokenRatio != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(TokenRatio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (MaxTokens != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxTokens);
          }
          if (TokenRatio != 0F) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RetryThrottlingPolicy other) {
          if (other == null) {
            return;
          }
          if (other.MaxTokens != 0) {
            MaxTokens = other.MaxTokens;
          }
          if (other.TokenRatio != 0F) {
            TokenRatio = other.TokenRatio;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxTokens = input.ReadUInt32();
                break;
              }
              case 21: {
                TokenRatio = input.ReadFloat();
                break;
              }
            }
          }
        }

      }

      public sealed partial class HealthCheckConfig : pb::IMessage<HealthCheckConfig> {
        private static readonly pb::MessageParser<HealthCheckConfig> _parser = new pb::MessageParser<HealthCheckConfig>(() => new HealthCheckConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HealthCheckConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Grpc.ServiceConfig.ServiceConfig.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HealthCheckConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HealthCheckConfig(HealthCheckConfig other) : this() {
          ServiceName = other.ServiceName;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HealthCheckConfig Clone() {
          return new HealthCheckConfig(this);
        }

        /// <summary>Field number for the "service_name" field.</summary>
        public const int ServiceNameFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _single_serviceName_codec = pb::FieldCodec.ForClassWrapper<string>(10);
        private string serviceName_;
        /// <summary>
        /// Service name to use in the health-checking request.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ServiceName {
          get { return serviceName_; }
          set {
            serviceName_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HealthCheckConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HealthCheckConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ServiceName != other.ServiceName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (serviceName_ != null) hash ^= ServiceName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (serviceName_ != null) {
            _single_serviceName_codec.WriteTagAndValue(output, ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (serviceName_ != null) {
            size += _single_serviceName_codec.CalculateSizeWithTag(ServiceName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HealthCheckConfig other) {
          if (other == null) {
            return;
          }
          if (other.serviceName_ != null) {
            if (serviceName_ == null || other.ServiceName != "") {
              ServiceName = other.ServiceName;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                string value = _single_serviceName_codec.Read(input);
                if (serviceName_ == null || value != "") {
                  ServiceName = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
